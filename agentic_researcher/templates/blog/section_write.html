{% extends "base.html" %}
{% load static %}

{% block content %}
<link rel="stylesheet" href="{% static 'css/progress.css' %}">

<div class="blog-container">
  <!-- Sidebar: Feedback History -->
  <aside class="sidebar">
    <h3>Feedback History</h3>
    <ul id="feedback-history">
      <li>ðŸ”„ Loading historyâ€¦</li>
    </ul>
  </aside>

  <!-- Main Content -->
  <main class="main-content">
    <!-- Phase Tracker -->
    <div class="step-tracker">
      {% comment %}
        Build ordered list of section IDs
      {% endcomment %}
      {% with drafts=outline.drafts.all|dictsort:"section_order" %}
      <script>
        const SECTION_IDS = [
          {% for d in drafts %}{{ d.id }}{% if not forloop.last %}, {% endif %}{% endfor %}
        ];
      </script>
      {% endwith %}

      <a href="{% url 'outline_refine' outline_id=draft.outline.id %}" class="step completed">
        1. Outline
      </a>
      <a href="#" id="step-draft" class="step active">
        2. Draft
      </a>
      <a href="{% url 'blog_meta' outline_id=draft.outline.id %}" class="step" id="step-format">
        3. Format
      </a>
      <a href="{% url 'blog_finish' outline_id=draft.outline.id %}" class="step" id="step-finalize">
        4. Finalize
      </a>
    </div>

    <!-- Loader -->
    <div id="loader-section">
      <div class="spinner"></div>
      <p id="loader-text">Generating section draftâ€¦</p>
    </div>

    <!-- Draft Section -->
    <section id="draft-section" data-current-section-id="" style="display:none;">
      <h2 id="section-title"></h2>
      <div id="section-content" class="outline-list"></div>

      <form id="feedback-form" method="post">
        {% csrf_token %}
        <textarea id="feedback" name="feedback" rows="3" placeholder="Any edits or suggestions?"></textarea>
        <div class="button-group">
          <button id="looks-good" type="submit" name="feedback" value="OK">
            Looks Good, Next
          </button>
          <button type="submit">
            Apply Feedback
          </button>
        </div>
      </form>
    </section>
  </main>
</div>

<style>
  footer { display: none !important; }
  /* disable future steps */
  .step.disabled { pointer-events: none; opacity: 0.5; }
  /* History styling */
  #feedback-history li { cursor: pointer; padding: 0.2rem 0; }
  #feedback-history li:hover { text-decoration: underline; }
  #feedback-history li.finalized { color: #28a745; font-weight: bold; }
</style>
{% endblock %}

{% block extra_scripts %}
<script>
document.addEventListener("DOMContentLoaded", () => {
  const outlineId    = "{{ draft.outline.id }}";
  const initialId    = Number("{{ draft.id }}");
  const storageKey   = `sectionCache_${outlineId}`;
  const loader       = document.getElementById("loader-section");
  const loaderText   = document.getElementById("loader-text");
  const section      = document.getElementById("draft-section");
  const titleEl      = document.getElementById("section-title");
  const contentEl    = document.getElementById("section-content");
  const historyEl    = document.getElementById("feedback-history");
  const form         = document.getElementById("feedback-form");
  const textarea     = document.getElementById("feedback");
  const stepDraft    = document.getElementById("step-draft");
  const stepFormat   = document.getElementById("step-format");
  const stepFinalize = document.getElementById("step-finalize");

  // Load cached sections or start empty
  let cache = JSON.parse(localStorage.getItem(storageKey) || "{}");
  // rebuild history list
  historyEl.innerHTML = "";
  Object.values(cache).forEach(entry => {
    const li = document.createElement("li");
    li.textContent = entry.label;
    if (entry.finalized) li.classList.add("finalized");
    li.addEventListener("click", () => renderSection(entry.id));
    historyEl.appendChild(li);
  });

  function saveCache() {
    localStorage.setItem(storageKey, JSON.stringify(cache));
  }

  function recordHistory(id, label, finalized=false) {
    cache[id] = {
      id,
      label,
      title:   titleEl.textContent,
      content: contentEl.innerHTML,
      finalized
    };
    saveCache();
    const li = document.createElement("li");
    li.textContent = label;
    if (finalized) li.classList.add("finalized");
    li.addEventListener("click", () => renderSection(id));
    historyEl.appendChild(li);
    // unlock Draft step
    stepDraft.classList.remove("disabled");
  }

  function renderSection(id) {
    const entry = cache[id];
    titleEl.textContent = entry.title;
    contentEl.innerHTML = entry.content;
    section.dataset.currentSectionId = id;
    loader.style.display  = "none";
    section.style.display = "flex";
    updateNav();
  }

  async function fetchSection(id, feedback=null) {
    loader.style.display  = "flex";
    section.style.display = "none";
    loaderText.textContent = feedback
      ? "Refining this sectionâ€¦"
      : "Generating section draftâ€¦";

    const resp = await fetch(`/api/write/${outlineId}/`, {
      method: 'POST',
      headers: {
        'X-CSRFToken': '{{ csrf_token }}',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ section_id:id, feedback })
    });
    if (!resp.ok) throw new Error(resp.statusText);
    const data = await resp.json();

    // cache it
    cache[id] = {
      id,
      label: feedback ? `âœï¸ ${feedback}` : `âœ” ${data.section_title}`,
      title: data.section_title,
      content: data.content,
      finalized: false
    };
    saveCache();
    return data;
  }

  async function loadSection(id, feedback=null) {
    let data;
    if (!feedback && cache[id]) {
      // already have it
      renderSection(id);
      return;
    }
    data = await fetchSection(id, feedback);
    renderSection(data.id);
  }

  function updateNav() {
    // index of current
    const curIdx = SECTION_IDS.indexOf(Number(section.dataset.currentSectionId));
    SECTION_IDS.forEach((sid, idx) => {
      const stepEl = [stepDraft, stepFormat, stepFinalize][idx-1];
      if (!stepEl) return;
      if (idx <= curIdx) {
        stepEl.classList.remove("disabled");
        stepEl.href = ["#", "#", "#"][idx]  // keep Draft clickable
      } else {
        stepEl.classList.add("disabled");
      }
    });
  }

  // initial load of first draft
  loadSection(initialId).catch(console.error);

  form.addEventListener("submit", async e => {
    if (e.submitter.id === "looks-good") {
      const cur = Number(section.dataset.currentSectionId);
      recordHistory(cur, "âœ” Finalized section.", true);
      return; // let Django redirect to next section
    }
    e.preventDefault();
    const fb = textarea.value.trim();
    if (!fb) return;
    textarea.value = "";
    await loadSection(Number(section.dataset.currentSectionId), fb);
  });
});
</script>
{% endblock %}
